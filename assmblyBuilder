if __name__ == "__main__":
    import main


central_index = 0
def get_index():
    global central_index
    central_index += 1
    return central_index - 1

class Namespace(object):
    def __init__(self):
        # name / caller pairs
        self.state: list[tuple[str, object]] = []
    
    def add(self, name: str, parent: object):
        if name in self.state:
            joined = ' -> '.join([i[0] for i in (self.state+[name])])
            raise Exception(f'recursion detected "{name}" calls inside itself via:\n')
        self.state.append(name, parent)

class Command(object):
    def __init__(self, cmd):
        self.cmd = cmd
    
    def translate(self, namespace: Namespace):
        return []

Program = list[Command]

class Variable(object):
    def __init__(self, name: str):
        self.name = name

class Value(object):
    def __init__(self, value):
        self.value = value

class Comparator(object):
    def __init__(self, comparator: str):
        if comparator not in ['<', '>', '==', '!=', '<=', '>=']:
            raise Exception(f'comparator "{comparator}" is not a valid comparator')
        self.comparator = comparator

Instance = Variable | Value
Condition = tuple[Instance, Comparator, Instance]

class Nop(Command):
    def __init__(self):
        super().__init__('nop')
    
    def translate(self, namespace: Namespace):
        return []

class Operator(object):
    def __init__(self, operator: str):
        if operator not in ['+', '-', '*', '/', '%', '^']:
            raise Exception(f'operator "{operator}" is not a valid operator')
        self.operator = operator


class DynamiclyAssignedVariable(Variable):
    def __init__(self, name: str, pointer_addr: int):
        super().__init__(name)
        self.pointer_addr = pointer_addr
        self.pointer_name = f'var_dyn_{name}_{get_index()}'

class StaticlyAssignedVariable(Variable):
    def __init__(self, name: str, addr: int):
        super().__init__(name)
        self.addr = addr
        self.pointer_name = f'var_dyn_{name}_{get_index()}'


class Function(object):
    def __init__(self, name, inputs, code):
        self.name: str = name
        self.inputs: list[Variable] = inputs
        self.code: Program = code

class Branch(Command):
    def __init__(self, condition_code_pairs):
        super().__init__('branch')
        self.condition_code_pairs: dict[Condition, Program] = condition_code_pairs

class WhileLoop(Command):
    def __init__(self, condition: Condition, code: Program):
        super().__init__('while')
        self.init = Nop()
        self.condition: Condition = condition
        self.code: Program = code
    
    def translate(self, namespace: Namespace):
        self.break_jump = f'while_break_{get_index()}'
        self.start_jump = f'while_start_{get_index()}'
        out = []
        out += self.init.translate(namespace)
        out.append(f'JMIF {self.condition.translate(namespace)} ~{self.start_jump}')
        out.append(f'JUMP ~{self.break_jump}')
        out.append(f'{self.start_jump}:')
        out += [i.translate(namespace) for i in self.code]
        out.append(f'JUMP ~{self.start_jump}')
        out.append(f'{self.break_jump}:')
        return out

class ForLoop(WhileLoop):
    def __init__(self, init: Command, condition: Condition, step: Command, code: Program):
        super().__init__(condition, code)
        self.init: Command = init
        self.code.append(step)

class Print(Command):
    def __init__(self, value: Instance):
        super().__init__('print')
        self.value: Instance = value

class Assignment(Command):
    def __init__(self, variable: Variable, value: Instance):
        super().__init__('assign')
        self.variable: Variable = variable
        self.value: Instance = value

class Modification(Command):
    def __init__(self, variable: Variable, operator: Operator, value: Instance):
        super().__init__('modify')
        self.variable: Variable = variable
        self.operator: Operator = operator
        self.value: Instance = value

class Definition(Command):
    def __init__(self, variable: Variable, value: Instance):
        super().__init__('define')
        self.variable: Variable = variable
        self.value: Instance = value

class Return(Command):
    def __init__(self, value: Instance):
        super().__init__('return')
        self.value: Instance = value

class Continue(Command):
    def __init__(self):
        super().__init__('continue')

class Break(Command):
    def __init__(self):
        super().__init__('break')

class FunctionCall(Command):
    def __init__(self, name: str, inputs: list[Instance]):
        super().__init__('call')
        self.name: str = name
        self.inputs: list[Instance] = inputs